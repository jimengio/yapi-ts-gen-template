import { Spec } from "swagger-schema-official";
import { pathPreferences } from "../src/preference";
let swaggerSpec: Spec = require("./swagger-api.json");

import * as fs from "fs";
import * as path from "path";
import * as prettier from "prettier";
import { getPathChunks } from "@jimengio/yapi-ts-generator/lib/generator/util/string";
import { generateApiTreeCode, checkPaths, buildTree } from "@jimengio/yapi-ts-generator/lib/generator/main";
import { definedQueryTypes } from "../src/preference";

export let byPublicApi = (tags: string[]) => {
  if (tags == null || tags.length === 0) {
    return false;
  }
  // 对应 YAPI 侧边栏上的分类, 支持过滤出其中一部分来生成, 默认是用 `api.` 这个这个前缀开头.
  // 之所以这样设计, 是因为存在一个 YAPI 仓库可能要生成多套 API 的情况, 可以借助不同前缀区分,
  // 比如增加另一组 bbb, 那么后边生成代码的逻辑可以针对 bbb 再写一份, 生成另一个文件, 以及对应的 config 入口
  let ns = tags[0].split(".")[0];

  return ns === "api";
};

// 检查代码是否正常

checkPaths(Object.keys(pathPreferences), Object.keys(swaggerSpec.paths));

// 基于路径分离出 chunks

let definedPaths = Object.keys(swaggerSpec.paths).slice().sort();

interface IPathInfo {
  original: string;
  chunks: string[];
}

let activePaths: IPathInfo[] = definedPaths
  .filter((urlPath) => {
    let ignored = pathPreferences[urlPath]?.ignored;
    return ignored == null || ignored === false;
  })
  .map((urlPath) => {
    return {
      original: urlPath,
      chunks: getPathChunks(urlPath),
    };
  });

// 基于 chunks 创建属性结构

interface IPathNode {
  chunk: string;
  original: string;
  children: IPathNode[];
}

let apiTree: IPathNode[] = buildTree(
  activePaths.filter((pathNode) => {
    let pathObject = swaggerSpec.paths[pathNode.original];
    return byPublicApi(pathObject.get?.tags) || byPublicApi(pathObject.post?.tags) || byPublicApi(pathObject.put?.tags) || byPublicApi(pathObject.delete?.tags);
  })
);

// console.log("publich apis:", JSON.stringify(apiTree, null, 2));
// console.log("internal apis:", JSON.stringify(internalApiTree, null, 2));

// 开始生成代码

let generatedCode = generateApiTreeCode(swaggerSpec, "genSeedApiTree", apiTree, byPublicApi, pathPreferences, definedQueryTypes);

// Format with Prettier
let prettierConfigs = JSON.parse(fs.readFileSync(path.join(process.env.PWD, ".prettierrc"), "utf8"));
prettierConfigs.parser = "typescript";

try {
  generatedCode = prettier.format(generatedCode, prettierConfigs);
} catch (error) {
  console.log(error);
  console.log("格式化没有成功, 使用原始代码");
}

let lineSeparator = `\n/** Generated by generator */\n`;
let publicFile = "src/generated-api-tree.ts";

// Read write file

let writeFile = (fileName: string, code: string) => {
  let previousCode = fs.readFileSync(fileName, "utf8");
  let staticPart = previousCode.split(lineSeparator)[0];
  fs.writeFileSync(fileName, `${staticPart}${lineSeparator}\n${code}`);
  console.log(`Wrote code to ${fileName}`);
};

writeFile(publicFile, generatedCode);
